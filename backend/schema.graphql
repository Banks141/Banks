type AccessToken {
  accessToken: String!
  accessTokenExpiration: String
}

"""A single Comment."""
type Comment implements Node {
  id: ID!
  user: User!
  post: Post!
  body: String!
  createdAt: String
  updatedAt: String
}

input CommentBodyFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

type CommentConnection {
  nodes: [Comment]!
  pageInfo: PageInfo
}

input CommentCreatedAtFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input CommentFilterInput {
  id: CommentIdFilterInput
  user: CommentUserFilterInput
  post: CommentPostFilterInput
  body: CommentBodyFilterInput
  createdAt: CommentCreatedAtFilterInput
  updatedAt: CommentUpdatedAtFilterInput
  or: [CommentFilterInput]
  and: [CommentFilterInput]
}

input CommentIdFilterInput {
  value: ID!
  comparator: FilterComparatorSymbol
}

input CommentOrderByInput {
  id: OrderByDirection
  user: OrderByDirection
  post: OrderByDirection
  body: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
}

input CommentPostFilterInput {
  value: ID!
  comparator: FilterComparatorSymbol
}

input CommentUpdatedAtFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input CommentUserFilterInput {
  value: ID!
  comparator: FilterComparatorSymbol
}

type CompleteSocialAuthenticationPayload {
  tokens: Tokens
  user: User!
}

input CreateCommentInput {
  post: ID!
  body: String!
}

type CreateCommentPayload {
  comment: Comment
}

input CreateMarketInput {
  symbol: String!
  name: String!
  fullName: String!
  description: String
  imageUrl: String
  exchange: MarketExchangeEnum
  price: Float
  priceClose: Float
  priceUpdatedAt: String
  numberOfPosts: Float
  partnerId: String
  icId: String
}

type CreateMarketPayload {
  market: Market
}

input CreatePostInput {
  title: String!
  body: String!
  market: ID!
  smImageUrl: String
  lgImageUrl: String
}

type CreatePostPayload {
  post: Post
}

input CreatePostVoteInput {
  post: ID!
  value: PostVoteValueEnum!
}

type CreatePostVotePayload {
  postVote: PostVote
}

input CreateUserInput {
  username: String!
  email: String!
  password: String
  verified: Boolean
  fullName: String
  website: String
}

type CreateUserPayload {
  user: User
}

input DeleteCommentInput {
  id: ID!
}

type DeleteCommentPayload {
  result: Boolean!
}

input DeleteMarketInput {
  symbol: String!
}

type DeleteMarketPayload {
  result: Boolean!
}

input DeletePostInput {
  slug: String!
}

type DeletePostPayload {
  result: Boolean!
}

input DeletePostVoteInput {
  id: ID!
}

type DeletePostVotePayload {
  result: Boolean!
}

input DeleteUserInput {
  username: String!
}

type DeleteUserPayload {
  result: Boolean!
}

"""Specify how 2 values are going to be compared."""
enum FilterComparatorSymbol {
  EQUAL
  NOT_EQUAL
  GREATER_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN
  LESS_THAN_OR_EQUAL
}

type LoginPayload {
  tokens: Tokens
  user: User!
}

type LogoutPayload {
  result: Boolean
}

"""A single Market."""
type Market implements Node {
  symbol: String!
  name: String!
  fullName: String!
  description: String
  imageUrl: String
  exchange: MarketExchangeEnum
  price: Float
  priceClose: Float
  priceUpdatedAt: String
  numberOfPosts: Float
  partnerId: String
  icId: String
  id: ID!
  createdAt: String
  updatedAt: String
}

type MarketConnection {
  nodes: [Market]!
  pageInfo: PageInfo
}

input MarketCreatedAtFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input MarketDescriptionFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

enum MarketExchangeEnum {
  NYSE
  NASDAQ
}

input MarketExchangeFilterInput {
  value: MarketExchangeEnum!
  comparator: FilterComparatorSymbol
}

input MarketFilterInput {
  symbol: MarketSymbolFilterInput
  name: MarketNameFilterInput
  fullName: MarketFullNameFilterInput
  description: MarketDescriptionFilterInput
  imageUrl: MarketImageUrlFilterInput
  exchange: MarketExchangeFilterInput
  price: MarketPriceFilterInput
  priceClose: MarketPriceCloseFilterInput
  priceUpdatedAt: MarketPriceUpdatedAtFilterInput
  numberOfPosts: MarketNumberOfPostsFilterInput
  partnerId: MarketPartnerIdFilterInput
  icId: MarketIcIdFilterInput
  id: MarketIdFilterInput
  createdAt: MarketCreatedAtFilterInput
  updatedAt: MarketUpdatedAtFilterInput
  or: [MarketFilterInput]
  and: [MarketFilterInput]
}

input MarketFullNameFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input MarketIcIdFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input MarketIdFilterInput {
  value: ID!
  comparator: FilterComparatorSymbol
}

input MarketImageUrlFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input MarketNameFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input MarketNumberOfPostsFilterInput {
  value: Float!
  comparator: FilterComparatorSymbol
}

input MarketOrderByInput {
  symbol: OrderByDirection
  name: OrderByDirection
  fullName: OrderByDirection
  description: OrderByDirection
  imageUrl: OrderByDirection
  exchange: OrderByDirection
  price: OrderByDirection
  priceClose: OrderByDirection
  priceUpdatedAt: OrderByDirection
  numberOfPosts: OrderByDirection
  partnerId: OrderByDirection
  icId: OrderByDirection
  id: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
}

input MarketPartnerIdFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input MarketPriceCloseFilterInput {
  value: Float!
  comparator: FilterComparatorSymbol
}

input MarketPriceFilterInput {
  value: Float!
  comparator: FilterComparatorSymbol
}

input MarketPriceUpdatedAtFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input MarketSymbolFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input MarketUpdatedAtFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

"""The root query for implementing GraphQL mutations."""
type Mutation {
  """Create a User."""
  createUser(input: CreateUserInput): CreateUserPayload

  """Update a User."""
  updateUser(input: UpdateUserInput): UpdateUserPayload

  """Delete a User."""
  deleteUser(input: DeleteUserInput): DeleteUserPayload

  """Login using username/email and password."""
  login(username: String!, password: String!): LoginPayload

  """Logout the current user."""
  logout: LogoutPayload

  """Verify an email using the verification code."""
  verifyEmail(username: String!, code: String!): VerifyPayload

  """Send an email with a link for resetting the password."""
  sendResetPasswordEmail(username: String!): SendResetPasswordEmailPayload

  """Reset a password using a verification code."""
  resetPassword(username: String!, password: String!, code: String!): ResetPasswordPayload

  """Reset a password using a verification code."""
  completeSocialAuthentication(provider: String!, code: String!, username: String): CompleteSocialAuthenticationPayload

  """Create a Comment."""
  createComment(input: CreateCommentInput): CreateCommentPayload

  """Update a Comment."""
  updateComment(input: UpdateCommentInput): UpdateCommentPayload

  """Delete a Comment."""
  deleteComment(input: DeleteCommentInput): DeleteCommentPayload

  """Create a Market."""
  createMarket(input: CreateMarketInput): CreateMarketPayload

  """Update a Market."""
  updateMarket(input: UpdateMarketInput): UpdateMarketPayload

  """Delete a Market."""
  deleteMarket(input: DeleteMarketInput): DeleteMarketPayload

  """Create a PostVote."""
  createPostVote(input: CreatePostVoteInput): CreatePostVotePayload

  """Update a PostVote."""
  updatePostVote(input: UpdatePostVoteInput): UpdatePostVotePayload

  """Delete a PostVote."""
  deletePostVote(input: DeletePostVoteInput): DeletePostVotePayload

  """Create a Post."""
  createPost(input: CreatePostInput): CreatePostPayload

  """Update a Post."""
  updatePost(input: UpdatePostInput): UpdatePostPayload

  """Delete a Post."""
  deletePost(input: DeletePostInput): DeletePostPayload
}

"""An object with an ID."""
interface Node {
  id: ID!
}

"""Specify the direction on which the items are going to be returned."""
enum OrderByDirection {
  DESC
  ASC
}

type PageInfo {
  startCursor: String
  endCursor: String
  hasPreviousPage: Boolean
  hasNextPage: Boolean
}

"""A single Post."""
type Post implements Node {
  slug: String!
  user: User!
  title: String!
  body: String!
  market: Market!
  numberOfComments: Float
  votes: Float
  smImageUrl: String
  lgImageUrl: String
  id: ID!
  createdAt: String
  updatedAt: String
  viewerVote: PostVote
}

input PostBodyFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

type PostConnection {
  nodes: [Post]!
  pageInfo: PageInfo
}

input PostCreatedAtFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input PostFilterInput {
  slug: PostSlugFilterInput
  user: PostUserFilterInput
  title: PostTitleFilterInput
  body: PostBodyFilterInput
  market: PostMarketFilterInput
  numberOfComments: PostNumberOfCommentsFilterInput
  votes: PostVotesFilterInput
  smImageUrl: PostSmImageUrlFilterInput
  lgImageUrl: PostLgImageUrlFilterInput
  id: PostIdFilterInput
  createdAt: PostCreatedAtFilterInput
  updatedAt: PostUpdatedAtFilterInput
  or: [PostFilterInput]
  and: [PostFilterInput]
}

input PostIdFilterInput {
  value: ID!
  comparator: FilterComparatorSymbol
}

input PostLgImageUrlFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input PostMarketFilterInput {
  value: ID!
  comparator: FilterComparatorSymbol
}

input PostNumberOfCommentsFilterInput {
  value: Float!
  comparator: FilterComparatorSymbol
}

input PostOrderByInput {
  slug: OrderByDirection
  user: OrderByDirection
  title: OrderByDirection
  body: OrderByDirection
  market: OrderByDirection
  numberOfComments: OrderByDirection
  votes: OrderByDirection
  smImageUrl: OrderByDirection
  lgImageUrl: OrderByDirection
  id: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
}

input PostSlugFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input PostSmImageUrlFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input PostTitleFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input PostUpdatedAtFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input PostUserFilterInput {
  value: ID!
  comparator: FilterComparatorSymbol
}

"""A single PostVote."""
type PostVote implements Node {
  id: ID!
  user: User!
  post: Post!
  value: PostVoteValueEnum!
  createdAt: String
  updatedAt: String
}

type PostVoteConnection {
  nodes: [PostVote]!
  pageInfo: PageInfo
}

input PostVoteCreatedAtFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input PostVoteFilterInput {
  id: PostVoteIdFilterInput
  user: PostVoteUserFilterInput
  post: PostVotePostFilterInput
  value: PostVoteValueFilterInput
  createdAt: PostVoteCreatedAtFilterInput
  updatedAt: PostVoteUpdatedAtFilterInput
  or: [PostVoteFilterInput]
  and: [PostVoteFilterInput]
}

input PostVoteIdFilterInput {
  value: ID!
  comparator: FilterComparatorSymbol
}

input PostVoteOrderByInput {
  id: OrderByDirection
  user: OrderByDirection
  post: OrderByDirection
  value: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
}

input PostVotePostFilterInput {
  value: ID!
  comparator: FilterComparatorSymbol
}

input PostVotesFilterInput {
  value: Float!
  comparator: FilterComparatorSymbol
}

input PostVoteUpdatedAtFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input PostVoteUserFilterInput {
  value: ID!
  comparator: FilterComparatorSymbol
}

enum PostVoteValueEnum {
  POSITIVE_1
  NEGATIVE_1
}

input PostVoteValueFilterInput {
  value: PostVoteValueEnum!
  comparator: FilterComparatorSymbol
}

"""The query root of the GraphQL interface."""
type Query {
  """Find Users."""
  users(first: Int, last: Int, before: String, after: String, filter: UserFilterInput, orderBy: [UserOrderByInput]): UserConnection

  """Find a User by username."""
  user(username: String!): User!

  """The currently authenticated user."""
  viewer: User!

  """Get a new access token given a refresh token."""
  accessToken(username: String!, refreshToken: String!): AccessToken

  """Find Comments."""
  comments(first: Int, last: Int, before: String, after: String, filter: CommentFilterInput, orderBy: [CommentOrderByInput]): CommentConnection

  """Find a Comment by id."""
  comment(id: String!): Comment!

  """Find Markets."""
  markets(first: Int, last: Int, before: String, after: String, filter: MarketFilterInput, orderBy: [MarketOrderByInput], search: String): MarketConnection

  """Find a Market by symbol."""
  market(symbol: String!): Market!

  """Find PostVotes."""
  postVotes(first: Int, last: Int, before: String, after: String, filter: PostVoteFilterInput, orderBy: [PostVoteOrderByInput]): PostVoteConnection

  """Find a PostVote by id."""
  postVote(id: String!): PostVote!

  """Find Posts."""
  posts(first: Int, last: Int, before: String, after: String, filter: PostFilterInput, orderBy: [PostOrderByInput]): PostConnection

  """Find a Post by slug."""
  post(slug: String!): Post!
}

type ResetPasswordPayload {
  result: Boolean
}

type SendResetPasswordEmailPayload {
  result: Boolean
}

type Tokens {
  accessToken: String!
  accessTokenExpiration: String
  refreshToken: String
}

input UpdateCommentInput {
  id: ID!
  post: ID
  body: String
}

type UpdateCommentPayload {
  comment: Comment
}

input UpdateMarketInput {
  symbol: String!
  name: String
  fullName: String
  description: String
  imageUrl: String
  exchange: MarketExchangeEnum
  price: Float
  priceClose: Float
  priceUpdatedAt: String
  numberOfPosts: Float
  partnerId: String
  icId: String
}

type UpdateMarketPayload {
  market: Market
}

input UpdatePostInput {
  slug: String!
  title: String
  body: String
  smImageUrl: String
  lgImageUrl: String
}

type UpdatePostPayload {
  post: Post
}

input UpdatePostVoteInput {
  id: ID!
}

type UpdatePostVotePayload {
  postVote: PostVote
}

input UpdateUserInput {
  username: String!
  email: String
  password: String
  verified: Boolean
  fullName: String
  website: String
}

type UpdateUserPayload {
  user: User
}

"""A single User."""
type User implements Node {
  username: String!
  id: ID!
  email: String!
  verified: Boolean
  admin: Boolean
  numberOfPosts: Float
  numberOfComments: Float
  fullName: String
  website: String
  createdAt: String
  updatedAt: String
}

input UserAdminFilterInput {
  value: Boolean!
  comparator: FilterComparatorSymbol
}

type UserConnection {
  nodes: [User]!
  pageInfo: PageInfo
}

input UserCreatedAtFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input UserEmailFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input UserFilterInput {
  username: UserUsernameFilterInput
  id: UserIdFilterInput
  email: UserEmailFilterInput
  verified: UserVerifiedFilterInput
  admin: UserAdminFilterInput
  numberOfPosts: UserNumberOfPostsFilterInput
  numberOfComments: UserNumberOfCommentsFilterInput
  fullName: UserFullNameFilterInput
  website: UserWebsiteFilterInput
  createdAt: UserCreatedAtFilterInput
  updatedAt: UserUpdatedAtFilterInput
  or: [UserFilterInput]
  and: [UserFilterInput]
}

input UserFullNameFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input UserIdFilterInput {
  value: ID!
  comparator: FilterComparatorSymbol
}

input UserNumberOfCommentsFilterInput {
  value: Float!
  comparator: FilterComparatorSymbol
}

input UserNumberOfPostsFilterInput {
  value: Float!
  comparator: FilterComparatorSymbol
}

input UserOrderByInput {
  username: OrderByDirection
  id: OrderByDirection
  email: OrderByDirection
  verified: OrderByDirection
  admin: OrderByDirection
  numberOfPosts: OrderByDirection
  numberOfComments: OrderByDirection
  fullName: OrderByDirection
  website: OrderByDirection
  createdAt: OrderByDirection
  updatedAt: OrderByDirection
}

input UserUpdatedAtFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input UserUsernameFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

input UserVerifiedFilterInput {
  value: Boolean!
  comparator: FilterComparatorSymbol
}

input UserWebsiteFilterInput {
  value: String!
  comparator: FilterComparatorSymbol
}

type VerifyPayload {
  result: Boolean
}
